// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./LinxirToken.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title LinxirGaming
 * @notice Handles the game interaction logic for Linxir players.
 *         Tracks deposits per game, manages win/loss outcomes,
 *         supports token burning, pause control and per-game token retention stats.
 */
contract LinxirGaming is Ownable {
    LinxirToken public immutable token;
    address public immutable tokenContract;

    /// @notice True if the game contract is paused (emergency only)
    bool public isPaused;

    /// @notice Tracks active play of a user in a specific game
    struct Play {
        uint256 amount;
        bool active;
    }

    /// @notice Custom burn config per game (optional override)
    struct BurnConfig {
        uint256 percent; // 0–100
        bool isSet;
    }

    uint256 public constant BASE_BURN_PERCENT = 50;

    // Per-game configurations
    mapping(uint256 => BurnConfig) public burnConfigByGame;
    mapping(uint256 => mapping(address => Play)) public plays;

    /// @notice Tracks retained tokens (not burned) per game
    mapping(uint256 => uint256) public retainedByGame;

    /// @notice Optional whitelist for valid game IDs
    mapping(uint256 => bool) public isWhitelistedGame;

    // ----------------------------
    // Events
    // ----------------------------

    event GamePlayed(uint256 indexed gameId, address indexed user, uint256 amount);
    event GamePaused();
    event GameResumed();
    event GameWhitelisted(uint256 gameId);
    event GameRemovedFromWhitelist(uint256 gameId);
    event GameBurnConfigured(uint256 gameId, uint256 percent);
    event GameResolved(
    uint256 indexed gameId,
        address indexed user,
        uint256 played,
        uint256 payout,
        uint256 burned,
        uint256 retained
    );
    event GamingWithdrawn(
        uint256 indexed gameId,
        address indexed to,
        uint256 amount
    );

    // ----------------------------
    // Constructor & Modifiers
    // ----------------------------

    constructor(address _tokenAddress) Ownable(msg.sender) {
        require(_tokenAddress != address(0), "Invalid token address");
        token = LinxirToken(_tokenAddress);
        tokenContract = _tokenAddress;
    }

    modifier onlyToken() {
        require(msg.sender == tokenContract, "Only token contract allowed");
        _;
    }

    modifier notPaused() {
        require(!isPaused, "Game is paused");
        _;
    }

    modifier onlyWhitelisted(uint256 gameId) {
        require(isWhitelistedGame[gameId], "Game not authorized");
        _;
    }

    // ----------------------------
    // Admin Controls
    // ----------------------------

    /**
     * @notice Pause all gameplay functions (emergency only)
     */
    function pauseGame() external onlyOwner {
        isPaused = true;
        emit GamePaused();
    }

    /**
     * @notice Resume all gameplay functions
     */
    function resumeGame() external onlyOwner {
        isPaused = false;
        emit GameResumed();
    }

    /**
     * @notice Whitelist a specific gameId
     */
    function whitelistGameId(uint256 gameId) external onlyOwner {
        require(gameId != 0, "Invalid gameId");
        isWhitelistedGame[gameId] = true;
        emit GameWhitelisted(gameId);
    }

    /**
     * @notice Remove a gameId from whitelist
     */
    function removeWhitelistedGame(uint256 gameId) external onlyOwner {
        isWhitelistedGame[gameId] = false;
        emit GameRemovedFromWhitelist(gameId);
    }

    /**
     * @notice Configure custom burn percent for a specific game
     */
    function setBurnPercentage(uint256 gameId, uint256 percent) external onlyOwner {
        require(gameId != 0, "Invalid gameId");
        require(percent <= 100, "Percent > 100");

        burnConfigByGame[gameId] = BurnConfig({
            percent: percent,
            isSet: true
        });

        emit GameBurnConfigured(gameId, percent);
    }

    /**
     * @notice Withdraws retained tokens generated by player losses
     * @dev Only retained tokens can be withdrawn (never initial liquidity or rewards)
     */
    function withdrawFromGaming(
        uint256 gameId,
        address to,
        uint256 amount
    ) external onlyOwner {
        require(to != address(0), "Invalid recipient");
        require(amount > 0, "Amount must be > 0");

        uint256 retained = retainedByGame[gameId];
        require(retained >= amount, "Amount exceeds retained balance");

        // Update retained balance FIRST (checks-effects-interactions)
        retainedByGame[gameId] = retained - amount;

        // Transfer retained tokens from gaming wallet
        token.withdrawGamingTokens(to, amount);

        emit GamingWithdrawn(gameId, to, amount);
    }

    // ----------------------------
    // Core Gameplay
    // ----------------------------

    /**
     * @notice Called by token contract after depositToGaming
     */
    function registerPlay(
        uint256 gameId,
        address user,
        uint256 amount
    ) external onlyToken notPaused onlyWhitelisted(gameId) {
        require(user != address(0), "Invalid user");
        require(amount > 0, "Amount must be > 0");

        Play storage p = plays[gameId][user];
        require(!p.active, "User already active on this game");

        p.amount = amount;
        p.active = true;

        emit GamePlayed(gameId, user, amount);
    }

    /**
     * @notice Resolves a game outcome (win, loss or partial payout)
     * @dev Backend provides the final payout amount.
     *      Any non-returned tokens follow burn/retain rules.
     */
    function resolveGame(
        uint256 gameId,
        address user,
        uint256 payout
    ) external onlyOwner onlyWhitelisted(gameId) {
        Play storage p = plays[gameId][user];
        require(p.active, "No active play");
        require(p.amount > 0, "Invalid play");

        uint256 played = p.amount;

        // ----------------------------
        // 1️⃣ Return payout to user (can be 0)
        // ----------------------------
        if (payout > 0) {
            token.vestTransferFromWallet(
                token.gamingWallet(),
                user,
                payout
            );
        }

        // ----------------------------
        // 2️⃣ Process consumed amount
        // ----------------------------
        uint256 consumed = played > payout ? played - payout : 0;

        uint256 burned = 0;
        uint256 retained = 0;

        if (consumed > 0) {
            uint256 burnPercent = BASE_BURN_PERCENT;
            BurnConfig memory cfg = burnConfigByGame[gameId];

            if (cfg.isSet) {
                burnPercent = cfg.percent;
            }

            burned = (consumed * burnPercent) / 100;
            retained = consumed - burned;

            if (burned > 0) {
                token.burnFromGaming(burned);
            }

            retainedByGame[gameId] += retained;
        }

        // ----------------------------
        // 3️⃣ Clear play
        // ----------------------------
        p.amount = 0;
        p.active = false;

        emit GameResolved(
            gameId,
            user,
            played,
            payout,
            burned,
            retained
        );
    }
}







